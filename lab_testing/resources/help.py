"""
Help and Documentation Resource Provider

Copyright (C) 2025 Dynamic Devices Ltd
License: GPL-3.0-or-later
"""

from typing import Any, Dict


def get_help_content() -> Dict[str, Any]:
    """Get comprehensive help documentation"""
    return {
        "overview": (
            "MCP server for remote embedded hardware testing in lab environment. "
            "Designed to make remote hardware development easy and accessible for engineers. "
            "Provides intelligent tooling with helpful guidance, best practices, and automated workflows."
        ),
        "mission": (
            "Making remote embedded hardware development easy and accessible for engineers. "
            "Engineers working remotely should be able to discover devices, set up secure access, "
            "run commands and tests, build and deploy applications, and clean up securely - all with "
            "minimal friction and helpful guidance at every step."
        ),
        "version": "0.4.0",
        "quick_start": {
            "title": "Quick Start Guide for Engineers",
            "description": "Get up and running with remote device access in minutes",
            "standard_vpn_setup": [
                "‚úÖ **Standard WireGuard VPN is working well** - Use this for hardware lab access",
                "1. Get VPN config file from your lab administrator",
                "2. Place config in: ~/.config/wireguard/wg0.conf or {LAB_TESTING_ROOT}/secrets/wg0.conf",
                "3. Connect: 'connect_vpn()' or ask AI: 'Connect to the lab VPN'",
                "4. Verify: 'vpn_status()' to check connection",
                "5. List devices: 'list_devices()' to see available devices",
                "",
                "**Note:** Standard VPN uses NetworkManager routing configuration to only route target networks, preserving internet connectivity.",
            ],
            "foundries_vpn_setup": [
                "‚úÖ **CURRENT STATUS: Foundries VPN is working!**",
                "",
                "**What's Working:**",
                "  ‚úÖ Client VPN connection (after peer registration)",
                "  ‚úÖ NetworkManager routing configuration (only routes VPN network, preserves internet)",
                "  ‚úÖ VPN status checking and connection tools",
                "  ‚úÖ Device listing via FoundriesFactory API",
                "  ‚úÖ Enable/disable VPN on devices",
                "  ‚úÖ Server-side `factory-wireguard-server` daemon running",
                "  ‚úÖ Devices with VPN enabled automatically added as peers",
                "  ‚úÖ Device-to-device communication enabled (via `enable_foundries_device_to_device` tool)",
                "",
                "**CRITICAL LEARNING - Device-to-Device Communication:**",
                "  ‚ö†Ô∏è  Foundries devices default to restrictive `allowed-ips=10.42.42.1/32` (server IP only)",
                "  ‚ö†Ô∏è  This setting syncs back to server, preventing device-to-device communication",
                "  ‚úÖ Solution: Use `enable_foundries_device_to_device(device_name)` tool to update device config",
                "  ‚úÖ Server daemon must run with `--allow-device-to-device` flag for clean installations",
                "  üìñ See `docs/FOUNDRIES_VPN_CLEAN_INSTALLATION.md` for complete setup guide",
                "",
                "**CRITICAL STEP - Client Peer Registration:**",
                "‚ö†Ô∏è  Before connecting, your client must be added as a peer on the Foundries WireGuard server.",
                "   This requires server administrator access. Contact: ajlennon@dynamicdevices.co.uk for assistance.",
                "   The server admin needs to:",
                "   1. Add your public key as a peer on the WireGuard server",
                "   2. Assign you an IP address from the VPN network (e.g., 10.42.42.10)",
                "   3. Save the server configuration",
                "",
                "**Easiest Method (Automated):**",
                "1. Install fioctl: https://github.com/foundriesio/fioctl",
                "2. Configure: Run 'fioctl login' in terminal",
                "3. Generate keys: 'wg genkey | tee privatekey | wg pubkey > publickey'",
                "4. Share your public key with VPN admin: ajlennon@dynamicdevices.co.uk",
                "5. Wait for admin to add you as a peer and assign an IP address",
                "6. Setup VPN: Ask AI 'Set up Foundries VPN' or call 'setup_foundries_vpn(auto_generate_config=True)'",
                "7. Edit config: Fill in your private key and assigned IP in the generated config file",
                "8. Connect: Call 'setup_foundries_vpn()' again after editing config",
                "9. Verify: 'verify_foundries_vpn_connection()' to test connectivity",
                "",
                "**Manual Method:**",
                "1. Generate keys: 'wg genkey | tee privatekey | wg pubkey > publickey'",
                "2. Share your public key with VPN admin: ajlennon@dynamicdevices.co.uk",
                "3. Wait for admin to add you as a peer and assign an IP address",
                "4. Get VPN config from FoundriesFactory web interface (if available)",
                "5. Or create config manually with server details from 'get_foundries_vpn_server_config()'",
                "6. Place config in: ~/.config/wireguard/foundries.conf",
                "7. Connect: 'connect_foundries_vpn()'",
                "8. List devices: 'list_foundries_devices()' to see Foundries devices",
                "9. Cache VPN IPs: 'manage_foundries_vpn_ip_cache(action='refresh')' to cache device VPN IPs from server",
                "10. Lookup VPN IP: 'manage_foundries_vpn_ip_cache(action='get', device_name='...')' to get cached VPN IP",
            ],
            "first_device_access": [
                "1. List devices: 'list_devices()' to see available devices",
                "2. Test connectivity: 'test_device(device_id)' to verify device is reachable",
                "3. Check SSH access: 'check_ssh_key_status(device_id)' to see if SSH key is installed",
                "4. Install SSH key if needed: 'install_ssh_key(device_id)' (may need password first time)",
                "5. Run command: 'ssh_to_device(device_id, \"uptime\")' to test SSH access",
                "6. For sudo commands: 'enable_passwordless_sudo(device_id)' (remember to disable when done!)",
            ],
            "file_transfer": [
                "**Single file:**",
                "  - Copy to device: 'copy_file_to_device(device_id, local_path, remote_path)'",
                "  - Copy from device: 'copy_file_from_device(device_id, remote_path, local_path)'",
                "",
                "**Multiple files:**",
                "  - Parallel transfer: 'copy_files_to_device_parallel(device_id, file_pairs)' - Fastest!",
                "  - Directory sync: 'sync_directory_to_device(device_id, local_dir, remote_dir)' - Requires rsync on device",
            ],
            "getting_help": [
                "Ask AI assistant: 'Show me help' or 'What tools are available?'",
                "Use help tool: Call 'help()' to get comprehensive documentation",
                "Check workflows: See 'common_workflows' section in help for step-by-step guides",
                "Troubleshooting: See 'troubleshooting' section in help for common issues",
            ],
        },
        "usage": {
            "basic": "Ask AI assistant to use tools (e.g., 'List devices in the lab', 'Connect to VPN')",
            "examples": [
                "List all devices: 'What devices are available?'",
                "Test connectivity: 'Can you test if the iMX93 board is reachable?'",
                "SSH command: 'Run uptime on the Sentai board'",
                "VPN control: 'Connect to the lab VPN' or 'Set up Foundries VPN'",
                "Power control: 'Turn on the E-ink board power'",
                "Start monitoring: 'Start monitoring power consumption'",
                "File transfer: 'Copy my app.bin to the iMX93 board'",
                "Setup access: 'Set up SSH access for the test board'",
                "Deploy application: 'Deploy my application files to the device'",
            ],
            "llm_guidance": [
                "**For LLMs calling tools:**",
                "  - **PRIORITY: Always check VPN status first** before device operations (vpn_status or foundries_vpn_status)",
                "  - **For new users:** Guide them through quick_start workflows - prioritize ease of use",
                "  - **Foundries VPN - CRITICAL STEP:** Before connecting, users must be registered as a peer on the WireGuard server.",
                "    This requires server administrator access. Always mention: Contact ajlennon@dynamicdevices.co.uk (Alex J Lennon) for peer registration.",
                "    Users need to: 1) Generate WireGuard keys, 2) Share public key with admin, 3) Wait for assigned IP address, 4) Then configure and connect.",
                "  - **Foundries VPN setup:** Use 'setup_foundries_vpn(auto_generate_config=True)' for easiest setup (after peer registration)",
                "  - **Foundries VPN - Device-to-Device:** After enabling VPN on device, use 'enable_foundries_device_to_device(device_name)' to enable device-to-device communication. This is required because Foundries devices default to restrictive `allowed-ips=10.42.42.1/32` which prevents device-to-device communication. See `docs/FOUNDRIES_VPN_CLEAN_INSTALLATION.md` for complete setup guide.",
                "  - Use list_devices to discover available devices before operations",
                "  - Test device connectivity with test_device before SSH/file operations",
                "  - Check SSH key status before file transfers (multiplexed connections require SSH keys)",
                "  - For file transfers: Choose the right tool based on number of files and rsync availability",
                "  - Provide helpful next_steps to users based on tool responses",
                "  - When errors occur, check the error message for specific suggestions",
                "  - Tools return 'next_steps' arrays - use these to guide users",
                "  - Remember to disable passwordless sudo when development/testing is finished",
                "  - Use device_id or friendly_name - both work for device identification",
                "  - **Help is comprehensive:** Direct users to 'help()' tool for detailed documentation",
            ],
        },
        "tools": {
            "device_management": {
                "list_devices": "List all devices with status, IPs, types, firmware, SSH status, last seen, and power switches. Returns brief summary (always visible) then full table. Supports filtering by device_type_filter, status_filter, ssh_status_filter, power_state_filter, search_query. Supports sorting (sort_by: ip/friendly_name/status/last_seen, sort_order: asc/desc) and limiting results (limit). Includes summary statistics (counts by type/status/SSH status). Shows Tasmota power state/consumption and test equipment detection. Power Switch column: For Tasmota devices, shows their own power state (üü¢ ON/üî¥ OFF); for other devices, shows which power switch controls them (if configured). Use force_refresh=true to bypass cache and rescan all devices.",
                "test_device": "Test connectivity to a device (ping and SSH check). Best practice: Use before running operations on devices. In DHCP environments, use verify_device_identity to ensure correct device.",
                "ssh_to_device": "Execute SSH command on a device (requires device_id, command, optional username). Best practice: Test device connectivity first with test_device.",
                "verify_device_identity": "Verify device identity at given IP matches expected device (important for DHCP). Updates IP in config if verified and changed.",
                "verify_device_by_ip": "Identify which device (if any) is at a given IP address by checking hostname/unique ID.",
                "update_device_ip": "Verify device identity and update IP address in config if device is verified and IP has changed (for DHCP environments).",
                "update_device_friendly_name": "Update friendly name for a discovered device in the cache. Allows custom names when referencing devices.",
            },
            "vpn_management": {
                "vpn_status": "Get current WireGuard VPN connection status",
                "connect_vpn": "Connect to WireGuard VPN for lab network access",
                "disconnect_vpn": "Disconnect from VPN",
            },
            "foundries_vpn_management": {
                "foundries_vpn_status": "Get Foundries VPN connection status. Foundries VPN uses WireGuard but with a server-based architecture where devices connect to a centralized VPN server managed by FoundriesFactory. Requires fioctl CLI tool to be installed and configured. ‚ö†Ô∏è CRITICAL: Your client must be registered as a peer on the server before connecting. Contact ajlennon@dynamicdevices.co.uk for assistance.",
                "get_foundries_vpn_server_config": "Get Foundries VPN server configuration using fioctl API. Returns WireGuard server endpoint (e.g., proxmox.dynamicdevices.co.uk), address, and public key. This uses the FoundriesFactory API to retrieve server configuration. Requires fioctl CLI tool to be installed and configured. ‚ö†Ô∏è CRITICAL: You still need to be registered as a peer on the server before connecting. Contact ajlennon@dynamicdevices.co.uk for assistance.",
                "check_foundries_vpn_client_config": "Check if Foundries VPN client configuration file exists and is valid. Validates WireGuard config format and required fields. Searches standard locations if config_path not provided. Use this to verify your config before connecting. ‚ö†Ô∏è CRITICAL: Config must include your assigned IP address from the server administrator. Contact ajlennon@dynamicdevices.co.uk if you need peer registration.",
                "generate_foundries_vpn_client_config_template": "Generate a Foundries VPN client configuration template with server details. Gets server config from FoundriesFactory and creates a template file that you fill in with your private key and assigned IP address. Requires fioctl CLI tool to be installed and configured. ‚ö†Ô∏è CRITICAL: You must be registered as a peer on the server first. Generate your keys, share public key with ajlennon@dynamicdevices.co.uk, and wait for assigned IP address before filling in the template.",
                "setup_foundries_vpn": "Automated end-to-end Foundries VPN setup. Checks prerequisites, validates or generates client config, and connects to VPN. This automates the entire setup process. Use auto_generate_config=True to generate template if config not found. Requires fioctl CLI tool and WireGuard tools. ‚ö†Ô∏è CRITICAL: Your client must be registered as a peer on the server before connecting. Contact ajlennon@dynamicdevices.co.uk for peer registration assistance.",
                "verify_foundries_vpn_connection": "Verify that Foundries VPN connection is working. Tests connectivity to VPN server and checks routing. Use this after connecting to ensure VPN is functioning correctly.",
                "connect_foundries_vpn": "Connect to Foundries VPN server. Requires a WireGuard configuration file obtained from FoundriesFactory. Searches for config in standard locations if not provided. Requires fioctl CLI tool. ‚ö†Ô∏è CRITICAL: Your client must be registered as a peer on the server before connecting. Contact ajlennon@dynamicdevices.co.uk for assistance.",
                "list_foundries_devices": "List all Foundries devices in a factory. Uses fioctl API to list devices in the FoundriesFactory. Returns comprehensive device information including name, target, status, apps, creation date, last seen, owner, tags, device group, OSTree hash, UUID, and more. VPN IP addresses are automatically included from cache if available. This tool lists ALL devices in the factory, not just VPN-enabled ones. Requires fioctl CLI tool to be installed and configured.",
                "enable_foundries_vpn_device": "Enable WireGuard VPN on a Foundries device. Uses fioctl API to enable WireGuard configuration on a device. The device will connect to the Foundries VPN server after OTA update (up to 5 minutes). Requires fioctl CLI tool.",
                "manage_foundries_vpn_ip_cache": "Manage Foundries VPN IP address cache. Query, update, and refresh the cache of Foundries device VPN IP addresses. The cache is populated from the WireGuard server's /etc/hosts file or manually. Actions: 'get' (get IP for device), 'list' (list all cached IPs), 'set' (manually set IP), 'remove' (remove entry), 'refresh' (refresh from WireGuard server). Useful for quickly looking up device VPN IPs without querying the server each time. Example: manage_foundries_vpn_ip_cache(action='get', device_name='imx8mm-jaguar-inst-2240a09dab86563') or manage_foundries_vpn_ip_cache(action='refresh') to refresh all IPs from server.",
                "disable_foundries_vpn_device": "Disable WireGuard VPN on a Foundries device. Uses fioctl API to disable WireGuard configuration on a device. The device will disconnect from the Foundries VPN server after OTA update (up to 5 minutes). Requires fioctl CLI tool.",
                "enable_foundries_device_to_device": "‚ö†Ô∏è CRITICAL TOOL: Enables device-to-device communication for a Foundries device by updating its NetworkManager WireGuard configuration to allow the full VPN subnet (10.42.42.0/24). This tool SSHes from the WireGuard server to the target device, modifies `/etc/NetworkManager/system-connections/factory-vpn0.nmconnection` to change `allowed-ips=10.42.42.1` to `allowed-ips=10.42.42.0/24`, reloads the NetworkManager connection, and sets the server-side AllowedIPs. Requires SSH access to the WireGuard server and device (using 'fio' user and password 'fio' by default). This is required because Foundries devices default to restrictive `allowed-ips=10.42.42.1/32` which prevents device-to-device communication.",
            },
            "power_monitoring": {
                "start_power_monitoring": "Start power monitoring session - supports DMM (SCPI) or Tasmota (energy monitoring). Optional: device_id, test_name, duration, monitor_type (dmm|tasmota)",
                "get_power_logs": "Get recent power monitoring logs (optional: test_name, limit)",
            },
            "tasmota_control": {
                "tasmota_control": "Control Tasmota power switch (device_id, action: on|off|toggle|status|energy)",
                "list_tasmota_devices": "List all configured Tasmota devices and the devices they control",
                "power_cycle_device": "Power cycle a device by controlling its Tasmota power switch (turns off, waits, then turns on). Optional: off_duration (default: 5 seconds).",
            },
            "test_equipment": {
                "list_test_equipment": "List all test equipment devices (DMM, oscilloscopes, etc.) found on the network. Includes both configured devices and auto-discovered devices.",
                "query_test_equipment": "Send a SCPI command to test equipment (DMM, etc.) and get the response. Common commands: *IDN? (identify), MEAS:VOLT:DC? (measure DC voltage), MEAS:CURR:DC? (measure DC current). Supports device_id from config or IP address.",
            },
            "ota_management": {
                "check_ota_status": "Check Foundries.io OTA update status (device_id)",
                "trigger_ota_update": "Trigger OTA update (device_id, target?)",
                "list_containers": "List Docker containers on device (device_id)",
                "deploy_container": "Deploy/update container (device_id, container_name, image)",
                "get_system_status": "Get system status: uptime, load, memory, disk, kernel (device_id)",
                "get_firmware_version": "Get firmware/OS version from /etc/os-release (device_id)",
                "get_foundries_registration_status": "Check Foundries.io registration, connection, update status (device_id)",
                "get_secure_boot_status": "Get detailed secure boot status: U-Boot, kernel, EFI, HAB/CAAM (device_id)",
                "get_device_identity": "Get device identity: hostname, SOC unique ID, Foundries registration name (device_id)",
            },
            "batch_operations": {
                "batch_operation": "Execute operation on multiple devices in parallel (device_ids[], operation, max_concurrent=5, ...)",
                "regression_test": "Run regression test sequence in parallel (device_group?|device_ids[], test_sequence?, max_concurrent=5)",
                "get_device_groups": "Get devices organized by groups/tags for rack management",
            },
            "power_analysis": {
                "analyze_power_logs": "Analyze power logs for low power/suspend detection (test_name?, device_id?, threshold_mw?)",
                "monitor_low_power": "Monitor device for low power consumption (device_id, duration?, threshold_mw?, sample_rate?)",
                "compare_power_profiles": "Compare power consumption across multiple test runs (test_names[], device_id?). Visualizes differences between test sessions.",
            },
            "credential_management": {
                "cache_device_credentials": "Cache SSH credentials (username/password) for a device. Credentials are stored securely in ~/.cache/ai-lab-testing/credentials.json. Prefer SSH keys over passwords when possible. Use this before install_ssh_key if you need to provide a password.",
                "check_ssh_key_status": "Check if SSH key authentication is working for a device. Returns status of key installation and whether default SSH keys exist. Use this to verify passwordless SSH setup before running commands.",
                "install_ssh_key": "Install SSH public key on target device for passwordless access. Uses default SSH key from ~/.ssh/id_rsa.pub or ~/.ssh/id_ed25519.pub. Requires password for initial access if key not already installed. Will use cached/default credentials if password not provided. Best practice: Use this after caching credentials or providing password.",
                "enable_passwordless_sudo": "Enable passwordless sudo on a device for testing/debugging. Creates a sudoers.d file that allows the SSH user to use sudo without a password. Validates the sudoers file with visudo before applying. Use disable_passwordless_sudo to revert changes when testing is finished. Best practice: Enable after installing SSH key, disable when done testing.",
                "disable_passwordless_sudo": "Disable passwordless sudo on a device (revert changes). Removes the sudoers.d file that was created by enable_passwordless_sudo. Use this when testing is finished to restore normal sudo behavior. Best practice: Always disable passwordless sudo when finished with development/testing.",
            },
            "file_transfer": {
                "copy_file_to_device": "Copy a single file from local machine to remote device. Optimized for speed using multiplexed SSH connections (ControlMaster). Supports compression (-C flag) for faster transfers over slow links. Preserves file permissions and timestamps by default. Example: copy_file_to_device('imx93_board', '/local/app.bin', '/remote/app.bin'). Best practice: For multiple files, use copy_files_to_device_parallel or sync_directory_to_device instead. NOTE: Large files (>50MB) may timeout on slow VPN links (60s timeout). Consider splitting large files or using parallel transfers for multiple smaller files.",
                "copy_file_from_device": "Copy a single file from remote device to local machine. Optimized for speed using multiplexed SSH connections (ControlMaster). Supports compression for faster transfers over slow links. Preserves file permissions and timestamps by default. Example: copy_file_from_device('imx93_board', '/remote/log.txt', '/local/log.txt'). Use this to retrieve logs, test results, or configuration files from devices. NOTE: Large files (>50MB) may timeout on slow VPN links (60s timeout).",
                "sync_directory_to_device": "Sync a local directory to remote device using rsync. Much faster than copying individual files. Optimized for speed using multiplexed SSH connections. Supports exclude patterns (exclude=['*.pyc', '__pycache__', '.git']) and delete option (delete=true to remove files on remote that don't exist locally). Example: sync_directory_to_device('imx93_board', '/local/project', '/remote/project', exclude=['*.pyc']). IMPORTANT: Requires rsync installed on remote device. Many embedded Linux devices don't have rsync by default. If rsync is not available, use copy_files_to_device_parallel instead. The tool will check for rsync and provide helpful suggestions if missing.",
                "copy_files_to_device_parallel": "Copy multiple files to remote device in parallel using multiplexed SSH connections. Much faster than copying files sequentially - all transfers share the same SSH connection (eliminates connection overhead). Tested and verified: 4.33x speedup over sequential transfers. Successfully tested with 100+ files (up to 200 files). Example: copy_files_to_device_parallel('imx93_board', [['/local/app.bin', '/remote/app.bin'], ['/local/config.json', '/remote/config.json']], max_workers=5). Best practice: Use this when deploying applications with multiple binaries/configs, or when rsync is not available on device. All files transfer simultaneously, sharing the same SSH connection for maximum speed. Optimal max_workers=5-10 for most scenarios.",
            },
        },
        "resources": {
            "device://inventory": "Complete device inventory JSON with all configured devices",
            "network://status": "Current network and VPN connection status",
            "config://lab_devices": "Raw lab devices configuration file",
            "help://usage": "This help documentation",
            "health://status": "Server health, metrics, SSH pool status, and uptime",
        },
        "configuration": {
            "lab_testing_root": "Path to lab testing framework (default: /data_drive/esl/ai-lab-testing)",
            "device_config": "Device inventory: {lab_testing_root}/config/lab_devices.json",
            "vpn_config": "VPN config: {lab_testing_root}/secrets/wg0.conf",
            "environment": "Override with LAB_TESTING_ROOT environment variable",
        },
        "common_workflows": {
            "remote_development_setup": [
                "1. Connect to VPN: 'connect_vpn' (check status first with 'vpn_status')",
                "2. Scan for targets: 'list_devices' to see all available boards/devices",
                "3. Choose your board: Review device list, filter by type/status, or search by IP/name",
                "4. Test connectivity: 'test_device(device_id)' to verify ping and SSH access",
                "5. Cache credentials (if needed): 'cache_device_credentials(device_id, username, password)'",
                "6. Install SSH key: 'install_ssh_key(device_id)' for passwordless SSH access",
                "7. Enable passwordless sudo: 'enable_passwordless_sudo(device_id)' for testing convenience",
                "8. Verify setup: 'ssh_to_device(device_id, \"whoami\")' and 'ssh_to_device(device_id, \"sudo whoami\")'",
                "9. You're ready! Run commands, copy files, build and test applications",
            ],
            "file_transfer_workflow": [
                "1. Single file upload: 'copy_file_to_device(device_id, local_path, remote_path)' - Fast, uses multiplexed SSH",
                "2. Multiple files upload: 'copy_files_to_device_parallel(device_id, [[local1, remote1], [local2, remote2]], max_workers=5)' - Parallel transfers, fastest for multiple files",
                "3. Directory sync: 'sync_directory_to_device(device_id, local_dir, remote_dir, exclude=[\"*.pyc\"])' - Requires rsync on device, best for large directories",
                "4. File download: 'copy_file_from_device(device_id, remote_path, local_path)' - Retrieve logs, results, configs",
                "5. All transfers use multiplexed SSH connections (ControlMaster) for maximum speed",
                "6. First transfer establishes connection (~1-2s), subsequent transfers reuse connection (near-zero overhead)",
                "7. Compression enabled by default for faster transfers over slow links",
                "8. If sync_directory_to_device fails with 'rsync not found', use copy_files_to_device_parallel instead",
            ],
            "file_transfer_decision_tree": [
                "**When to use which tool:**",
                "  - Single file ‚Üí copy_file_to_device",
                "  - Multiple files (<10) ‚Üí copy_files_to_device_parallel (fastest)",
                "  - Large directory with rsync available ‚Üí sync_directory_to_device (best for many files)",
                "  - Large directory without rsync ‚Üí copy_files_to_device_parallel (fallback)",
                "  - Download file from device ‚Üí copy_file_from_device",
                "  - Deploy application (binaries + configs) ‚Üí copy_files_to_device_parallel",
                "  - Sync project directory ‚Üí sync_directory_to_device (if rsync available) or copy_files_to_device_parallel",
            ],
            "remote_development_cleanup": [
                "1. Disable passwordless sudo: 'disable_passwordless_sudo(device_id)' to restore security",
                "2. (Optional) Remove SSH key: Manual removal from device's ~/.ssh/authorized_keys if needed",
                "3. Verify cleanup: 'ssh_to_device(device_id, \"sudo -n whoami\")' should require password",
            ],
            "check_lab_status": [
                "1. Use 'vpn_status' to check VPN connection",
                "2. Use 'list_devices' to see available devices (shows brief summary first, then full table)",
                "3. Filter devices: 'list_devices(device_type_filter=\"tasmota_device\")' or 'list_devices(status_filter=\"online\")'",
                "4. Filter by SSH status: 'list_devices(ssh_status_filter=\"error\")' to find devices with SSH issues",
                "5. Filter Tasmota by power: 'list_devices(power_state_filter=\"on\")' to find powered-on Tasmota devices",
                "6. Search devices: 'list_devices(search_query=\"192.168.2.18\")'",
                '7. Sort results: \'list_devices(sort_by="ip", sort_order="asc")\' or \'list_devices(sort_by="last_seen", sort_order="desc")\'',
                "8. Limit results: 'list_devices(limit=10)' to show only first 10 devices",
                "9. Force refresh: 'list_devices(force_refresh=true)' to bypass cache and rescan",
                "10. Use 'test_device' to verify connectivity",
            ],
            "device_discovery": [
                "1. Devices are automatically discovered via network scanning",
                "2. Tasmota devices detected via HTTP API (port 80)",
                "3. Test equipment (DMM) detected via SCPI ports (5025, 5024, 3490, 3491)",
                "4. Device information cached to speed up subsequent scans",
                "5. Use 'list_devices' to see all discovered devices with their status",
                "6. Update friendly names: 'update_device_friendly_name(ip, friendly_name)'",
            ],
            "remote_device_access": [
                "1. Ensure VPN connected (use 'connect_vpn' if needed)",
                "2. Check SSH key status: 'check_ssh_key_status(device_id)' to see if passwordless SSH is configured",
                "3. If SSH key not installed: 'install_ssh_key(device_id)' (may need password first time)",
                "4. Use 'ssh_to_device' with device_id and command",
                "5. Example: ssh_to_device('imx93_eink_board_2', 'uptime')",
                "6. For sudo commands: Enable passwordless sudo first with 'enable_passwordless_sudo(device_id)'",
            ],
            "foundries_vpn_workflow": [
                "**CRITICAL STEP - Client Peer Registration (REQUIRED FIRST):**",
                "‚ö†Ô∏è  Before you can connect, your client must be registered as a peer on the Foundries WireGuard server.",
                "   This step requires server administrator access and cannot be automated.",
                "",
                "   **What the server administrator needs to do:**",
                "   1. Get your WireGuard public key (you generate this locally)",
                "   2. Add your public key as a peer on the WireGuard server using:",
                "      sudo wg set factory peer YOUR_PUBLIC_KEY allowed-ips ASSIGNED_IP/32",
                "   3. Assign you an IP address from the VPN network (e.g., 10.42.42.10)",
                "   4. Save the server configuration: sudo wg-quick save factory",
                "",
                "   **Contact for assistance:**",
                "   - Email: ajlennon@dynamicdevices.co.uk (Alex J Lennon)",
                "   - Provide your WireGuard public key when requesting access",
                "",
                "**Automated Setup (After Peer Registration):**",
                "1. Generate your WireGuard key pair: 'wg genkey | tee privatekey | wg pubkey > publickey'",
                "2. Share your public key with VPN admin: ajlennon@dynamicdevices.co.uk",
                "3. Wait for admin to add you as a peer and assign an IP address",
                "4. Run automated setup: 'setup_foundries_vpn(auto_generate_config=True)' - checks prerequisites, generates template if needed",
                "5. Edit config file: Fill in your private key and assigned IP address from admin",
                "6. Run setup again: 'setup_foundries_vpn()' to connect after editing config",
                "7. Verify connection: 'verify_foundries_vpn_connection()' to test VPN connectivity",
                "",
                "**Manual Setup (After Peer Registration):**",
                "1. Generate your WireGuard key pair: 'wg genkey | tee privatekey | wg pubkey > publickey'",
                "2. Share your public key with VPN admin: ajlennon@dynamicdevices.co.uk",
                "3. Wait for admin to add you as a peer and assign an IP address",
                "4. Install fioctl CLI tool: https://github.com/foundriesio/fioctl",
                "5. Configure fioctl: Run 'fioctl login' to set up FoundriesFactory credentials",
                "6. Get VPN server config: 'get_foundries_vpn_server_config()' to see server endpoint (e.g., proxmox.dynamicdevices.co.uk)",
                "7. Generate config template: 'generate_foundries_vpn_client_config_template()' - creates template with server details",
                "8. Edit config: Fill in YOUR_PRIVATE_KEY_HERE with your private key and YOUR_VPN_IP_HERE with assigned IP from admin",
                "9. Check config: 'check_foundries_vpn_client_config()' to validate config file",
                "10. Connect to VPN: 'connect_foundries_vpn()' or 'setup_foundries_vpn()' - auto-detects config",
                "11. Verify connection: 'verify_foundries_vpn_connection()' to test VPN connectivity",
                "12. List Foundries devices: 'list_foundries_devices()' to see devices in factory",
                "13. Enable VPN on device: 'enable_foundries_vpn_device(device_name)' - waits for OTA update (up to 5 minutes)",
                "14. **CRITICAL: Enable device-to-device communication:** 'enable_foundries_device_to_device(device_name)' - Required because Foundries devices default to restrictive `allowed-ips=10.42.42.1/32` which prevents device-to-device communication. This updates device NetworkManager config and server-side AllowedIPs.",
                "15. Access devices: Devices accessible via Foundries VPN server after connection",
                "16. Disable VPN when done: 'disable_foundries_vpn_device(device_name)' if needed",
            ],
            "ota_update_workflow": [
                "1. Check current status: 'check_ota_status(device_id)'",
                "2. Trigger update: 'trigger_ota_update(device_id, target?)'",
                "3. Monitor: 'get_system_status(device_id)' to verify",
                "4. Check containers: 'list_containers(device_id)'",
            ],
            "container_deployment": [
                "1. List current containers: 'list_containers(device_id)'",
                "2. Deploy new container: 'deploy_container(device_id, name, image)'",
                "3. Verify: 'list_containers(device_id)' again",
            ],
            "low_power_analysis": [
                "1. Start monitoring: 'monitor_low_power(device_id, duration, threshold_mw)'",
                "2. Wait for monitoring to complete",
                "3. Analyze: 'analyze_power_logs(test_name, device_id, threshold_mw)'",
                "4. Compare profiles: 'compare_power_profiles([test1, test2])'",
            ],
            "regression_testing": [
                "1. Get device groups: 'get_device_groups()' to see available groups",
                "2. Run regression: 'regression_test(device_group, test_sequence?)'",
                "3. Or test specific devices: 'regression_test(device_ids=[...])'",
                "4. Review results for all devices",
            ],
            "rack_management": [
                "1. Group devices by tag/type in device config",
                "2. Use 'get_device_groups()' to see organization",
                "3. Use 'batch_operation(device_ids, operation)' for parallel ops",
                "4. Use 'regression_test(device_group)' for automated testing",
            ],
        },
        "troubleshooting": {
            "vpn_not_connecting": [
                "Check VPN config exists: 'list_vpn_configs' or 'vpn_setup_instructions'",
                "May require NetworkManager or sudo: 'setup_networkmanager_vpn' for non-root access",
                "Verify VPN config path: Check VPN_CONFIG_PATH environment variable",
            ],
            "foundries_vpn_not_connecting": [
                "**CRITICAL: Check if client peer is registered on server:**",
                "‚ö†Ô∏è  Your client must be added as a peer on the Foundries WireGuard server before connecting.",
                "",
                "**Check Registration:**",
                "  Use: check_client_peer_registered() to verify your client peer is registered",
                "  If not registered, use: register_foundries_vpn_client() (requires admin)",
                "  Or contact VPN administrator: ajlennon@dynamicdevices.co.uk (Alex J Lennon)",
                "",
                "**Bootstrap Scenario (Clean Installation):**",
                "  For clean installation, first admin needs initial server access (public IP or direct access) - one-time only",
                "  After first admin connects, all subsequent client registrations can be done via Foundries VPN",
                "  See: docs/FOUNDRIES_VPN_BOOTSTRAP.md for complete bootstrap workflow",
                "",
                "**Server Access:**",
                "  Once connected to Foundries VPN, server is accessible at 10.42.42.1",
                "  All server management can be done via Foundries VPN (no public IP needed after bootstrap)",
                "",
                "**Server Status:**",
                "  ‚úÖ `factory-wireguard-server` daemon is running",
                "  ‚úÖ Devices with VPN enabled are automatically added as peers",
                "  ‚úÖ Client peers managed via /etc/wireguard/factory-clients.conf (Priority 2 implemented)",
                "  ‚ö†Ô∏è  Verify `/etc/hosts` is populated on server (check server if hostnames don't resolve)",
                "",
                "**Other troubleshooting steps:**",
                "Check fioctl is installed: Tools will check and provide installation instructions if missing",
                "Check fioctl is configured: Run 'fioctl login' to configure FoundriesFactory credentials",
                "Verify VPN config file exists: Obtain WireGuard config from FoundriesFactory or generate template",
                "Check VPN config path: Place config in ~/.config/wireguard/foundries.conf or secrets/foundries-vpn.conf",
                "Verify config has correct values: Private key, assigned IP address, server endpoint, and server public key",
                "Verify VPN server is accessible: Check Foundries VPN server status with 'get_foundries_vpn_server_config()'",
                "Check NetworkManager connection: 'nmcli connection show foundries' - may need to import config first",
                "For device VPN: Ensure device has WireGuard enabled via 'enable_foundries_vpn_device' and wait for OTA update (up to 5 minutes)",
                "If connection times out: May need sudo access for wg-quick, or use NetworkManager method (import config first)",
            ],
            "device_not_found": [
                "Verify device_id in device inventory: 'list_devices' to see all available devices",
                "Check spelling (case-sensitive) and use either device_id or friendly_name",
                "In DHCP environments: use 'verify_device_identity' to ensure correct device",
                "Force refresh: 'list_devices(force_refresh=true)' to rescan network",
            ],
            "ssh_fails": [
                "Check SSH key status: 'check_ssh_key_status(device_id)'",
                "Install SSH key if needed: 'install_ssh_key(device_id)'",
                "Verify device is online: 'test_device(device_id)'",
                "Check VPN connection: 'vpn_status'",
                "SSH authentication prioritizes 'fio' user, then 'root'",
                "Check SSH status in device list: 'list_devices(ssh_status_filter=\"error\")'",
                "Cache credentials if needed: 'cache_device_credentials(device_id, username, password)'",
            ],
            "sudo_fails": [
                "Check if passwordless sudo is enabled: Try 'ssh_to_device(device_id, \"sudo -n whoami\")' - should fail if not enabled",
                "Enable passwordless sudo: 'enable_passwordless_sudo(device_id)' - creates sudoers.d file, validates with visudo",
                "Verify SSH key is installed first: 'check_ssh_key_status(device_id)' - passwordless sudo requires SSH key",
                "Check if user has sudo permissions on device",
                "Remember to disable when finished: 'disable_passwordless_sudo(device_id)' to restore security",
            ],
            "file_transfer_fails": [
                "Check SSH key is installed: 'check_ssh_key_status(device_id)' - multiplexed connections require SSH keys",
                "Verify device is online: 'test_device(device_id)' - ensure device is reachable",
                "Check VPN connection: 'vpn_status' - ensure VPN is connected for remote devices",
                "For sync_directory_to_device: Check if rsync is installed on device: 'ssh_to_device(device_id, \"which rsync\")'",
                "If rsync not found: Use 'copy_files_to_device_parallel' instead - works without rsync",
                "Check disk space on device: 'ssh_to_device(device_id, \"df -h\")' - ensure enough space for transfer",
                "Check file permissions: Ensure remote directory is writable: 'ssh_to_device(device_id, \"ls -ld /remote/path\")'",
                "For large files (>50MB): May timeout on slow VPN links (60s timeout) - consider splitting files or using parallel transfers",
                "If transfer times out: Split large files into smaller chunks, or use copy_files_to_device_parallel for multiple files",
                "Network speed: Transfer rates on VPN links may be slow (~0.01-0.02MB/s) - compression helps but may not overcome very slow links",
                "If transfer fails: Check error message for specific suggestions - tools provide helpful guidance",
            ],
            "tools_fail": [
                "Verify lab_testing_root path correct: Check LAB_TESTING_ROOT environment variable",
                "Check underlying scripts work: Test commands manually",
                "Review error messages for specific suggestions",
            ],
            "device_list_not_visible": [
                "Device list returns brief summary first (always visible), then full table",
                "If not visible, restart MCP server connection",
                "Use 'list_devices(force_refresh=true)' to force rescan",
            ],
            "cache_errors": [
                "Device cache uses atomic writes and thread-safe locking",
                "If errors occur, cache may be corrupted - clear cache directory and rescan",
                "Cache location: ~/.cache/ai-lab-testing/",
            ],
        },
        "learnings": {
            "vpn_architecture": {
                "standard_vpn": "‚úÖ Standard WireGuard VPN: Direct peer-to-peer connection to hardware lab network. Simple, reliable, works well. Uses NetworkManager routing to only route target networks, preserving internet connectivity.",
                "foundries_vpn": "‚úÖ Foundries VPN: Server-based architecture with centralized VPN server on Proxmox. Client connects to server, server daemon (`factory-wireguard-server`) monitors FoundriesFactory API and automatically manages device peers. More complex but enables automatic device discovery and management.",
                "key_difference": "Standard VPN: Manual peer configuration. Foundries VPN: Automatic peer management via server daemon that monitors FoundriesFactory API.",
            },
            "routing_configuration": {
                "critical_issue": "‚ö†Ô∏è CRITICAL: Without proper routing configuration, VPN becomes default route and breaks internet connectivity.",
                "solution": "NetworkManager routing configuration is essential. Foundries VPN connection explicitly: 1) Parses AllowedIPs from WireGuard config, 2) Sets ipv4.routes to only route AllowedIPs, 3) Sets ipv4.never-default yes to prevent VPN from becoming default route. This preserves internet connectivity while routing VPN network traffic correctly.",
                "implementation": "Implemented in `connect_foundries_vpn()` function in lab_testing/tools/foundries_vpn.py. Uses nmcli to configure NetworkManager connection after importing WireGuard config.",
                "testing": "Verified: Internet connectivity preserved when Foundries VPN connected. Only traffic to VPN network (10.42.42.0/24) routed through VPN.",
            },
            "server_daemon": {
                "function": "The `factory-wireguard-server` daemon on Proxmox server: 1) Monitors FoundriesFactory API for devices with `wireguard.enabled = true`, 2) Automatically adds devices as WireGuard peers when VPN enabled, 3) Updates `/etc/hosts` on server with device hostnames for easy access, 4) Removes peers when VPN disabled on devices.",
                "status": "‚úÖ Daemon is now running and working correctly. Devices with VPN enabled are automatically added as peers.",
                "requirements": "Requires valid OAuth2 credentials in `/root/fiocreds.json` on server. Credentials may expire or become invalid if factory keys change - need periodic refresh via `fioctl login`.",
                "location": "Daemon script: `/root/factory-wireguard-server/factory-wireguard.py` on Proxmox server.",
            },
            "client_tools": {
                "status": "‚úÖ All Foundries VPN client-side tools work correctly: connection, status checking, device listing, enable/disable VPN on devices.",
                "connection_method": "NetworkManager preferred (no root required). Falls back to wg-quick if NetworkManager not available (requires root).",
                "config_management": "Client config search order: 1) FOUNDRIES_VPN_CONFIG_PATH env var, 2) ~/.config/wireguard/foundries.conf, 3) secrets/foundries-vpn.conf, 4) /etc/wireguard/foundries.conf. Centralized config function ensures consistency.",
                "automation": "`setup_foundries_vpn()` provides automated end-to-end setup: checks prerequisites, validates/generates config, connects to VPN. `auto_generate_config=True` generates template if config not found.",
            },
            "device_management": {
                "discovery": "Foundries devices discovered via FoundriesFactory API using `fioctl devices list`. Returns device name, target, status, apps, update status.",
                "vpn_enable": "Enable VPN on device via `enable_foundries_vpn_device(device_name)`. Uses FoundriesFactory API. Device connects after OTA update (up to 5 minutes).",
                "peer_addition": "When VPN enabled on device, server daemon automatically detects via API and adds device as WireGuard peer. No manual peer configuration needed.",
                "hostname_resolution": "Server daemon populates `/etc/hosts` on server with device hostnames. Client may need local `/etc/hosts` entries or use IP addresses directly for SSH access.",
                "device_to_device_communication": "‚ö†Ô∏è CRITICAL LEARNING: Foundries devices, by default, configure WireGuard with restrictive `allowed-ips=10.42.42.1/32` (server IP only) in their NetworkManager configuration (`/etc/NetworkManager/system-connections/factory-vpn0.nmconnection`). This restrictive setting syncs back to the server when devices reconnect, overriding server-side `AllowedIPs` settings. To enable device-to-device communication: 1) Server daemon must run with `--allow-device-to-device` flag (sets server-side `AllowedIPs = 10.42.42.0/24`), 2) Device-side NetworkManager config must be updated to `allowed-ips=10.42.42.0/24` (use `enable_foundries_device_to_device` tool or manual SSH update), 3) NetworkManager connection must be reloaded. Both server-side and device-side changes are required. See `docs/FOUNDRIES_VPN_CLEAN_INSTALLATION.md` for complete setup guide.",
            },
            "troubleshooting_insights": {
                "server_access": "tmate works for interactive sessions but doesn't support non-interactive SSH commands. For automated access, need regular SSH or run commands interactively and share output.",
                "credential_refresh": "If factory keys change, server credentials in `/root/fiocreds.json` need refresh. Regenerate via `fioctl login` on machine with fioctl, convert to fiocreds.json format, update on server.",
                "hostname_resolution": "Device hostnames may not resolve locally. Check server `/etc/hosts` (populated by daemon) or use VPN IP addresses directly. Can add to local `/etc/hosts` for convenience.",
                "icmp_blocking": "Ping to VPN server may fail (ICMP blocked) but VPN routing still works. Use SSH or other protocols to verify connectivity.",
            },
            "best_practices_learned": {
                "vpn_choice": "Use standard WireGuard VPN for hardware lab access (simple, reliable). Use Foundries VPN for Foundries devices (automatic peer management, device discovery).",
                "routing_config": "Always configure VPN routing to only route target networks. Never allow VPN to become default route unless intentionally routing all traffic.",
                "networkmanager": "Prefer NetworkManager for VPN connections (no root required, better system integration, easier routing configuration).",
                "peer_registration": "Foundries VPN requires manual client peer registration on server (one-time setup). Server daemon handles device peers automatically.",
                "device_to_device_setup": "‚ö†Ô∏è CRITICAL: For clean Foundries VPN installation, server daemon must run with `--allow-device-to-device` flag. Devices require NetworkManager config update (`allowed-ips=10.42.42.0/24`) via `enable_foundries_device_to_device` tool or manual SSH update. Both server-side and device-side changes required. See `docs/FOUNDRIES_VPN_CLEAN_INSTALLATION.md` for complete guide.",
            },
        },
        "best_practices": [
            "**Remote Development Workflow:**",
            "  1. Always connect to VPN first: 'vpn_status' then 'connect_vpn' if needed",
            "  2. **VPN Choice:** Use standard WireGuard VPN for hardware lab access (working well). Foundries VPN for Foundries devices (fully operational - server daemon running, devices connected).",
            "  3. Scan and choose your target: 'list_devices' to see available boards",
            "  4. Test connectivity: 'test_device(device_id)' before operations",
            "  5. Set up credentials: 'install_ssh_key(device_id)' for passwordless SSH",
            "  6. Enable passwordless sudo: 'enable_passwordless_sudo(device_id)' for testing",
            "  7. Run your development tasks: commands, file transfers, builds, tests",
            "  8. Transfer files: Use 'copy_file_to_device', 'sync_directory_to_device', or 'copy_files_to_device_parallel'",
            "  9. Clean up when done: 'disable_passwordless_sudo(device_id)' to restore security",
            "",
            "**File Transfer Best Practices:**",
            "  - Single file: Use copy_file_to_device (fastest for one file)",
            "  - Multiple files (10+): Use copy_files_to_device_parallel (4.33x faster than sequential, tested with 100+ files)",
            "  - Large directory: Try sync_directory_to_device first (requires rsync), fallback to copy_files_to_device_parallel",
            "  - All transfers use multiplexed SSH (ControlMaster) - first transfer establishes connection (~1-2s), subsequent transfers reuse it (near-zero overhead)",
            "  - Compression enabled by default for faster transfers over slow links (helps with compressible data)",
            "  - Check SSH key status before transfers - multiplexed connections require SSH keys",
            "  - If sync_directory_to_device fails with 'rsync not found', automatically use copy_files_to_device_parallel",
            "  - Preserve permissions by default (preserve_permissions=true) - disable only if needed",
            "  - For parallel transfers, max_workers=5-10 is optimal (tested successfully with max_workers=10 for 100-200 files)",
            "  - Large files (>50MB): May timeout on slow VPN links (60s timeout) - split files or use parallel transfers",
            "  - Performance: Parallel transfers achieve 4.33x speedup over sequential (verified in testing)",
            "  - Scalability: Successfully tested with 100+ files (up to 200 files) - scales well",
            "",
            "**General Best Practices:**",
            "Always check VPN status before accessing lab devices",
            "Use test_device before executing SSH commands",
            "Install SSH keys for passwordless access (more secure than passwords)",
            "Enable passwordless sudo only when needed for testing, disable when finished",
            "Use descriptive test_name for power monitoring sessions",
            "Check device inventory resource for available device_ids",
            "For OTA updates: check status first, then trigger, monitor system_status",
            "For containers: list first, deploy with specific image tags, verify after",
            "For low power: set appropriate threshold_mw, monitor for sufficient duration",
            "For regression: organize devices by tags/groups, use batch operations",
            "Tag devices in config for easy rack management and grouping",
            "Use list_devices filters to quickly find specific devices (type, status, SSH status, power state, search)",
            "Use list_devices sorting (sort_by, sort_order) to organize results by IP, name, status, or last seen",
            "Use list_devices limit parameter to cap results for large networks",
            "Use list_devices force_refresh=true to bypass cache when you need fresh data",
            "Device list shows brief summary first - always visible without expanding",
            "In DHCP environments: verify device identity before operations, use update_device_ip if IP changed",
            "Device discovery is optimized with parallel SSH identification and caching",
            "Tasmota devices show power state (üü¢ ON/üî¥ OFF) in the Power Switch column and consumption (Watts) in the Type column of the device list",
            "Test equipment (DMM) can be queried with SCPI commands via query_test_equipment",
            "",
            "**LLM-Specific Guidance:**",
            "  - Tools return structured responses with 'success', 'error', 'message', and 'next_steps' fields",
            "  - Always check 'success' field before proceeding - if false, check 'error' and 'suggestions'",
            "  - Use 'next_steps' arrays from tool responses to guide users through workflows",
            "  - When a tool fails, check the error message for specific suggestions and related tools",
            "  - Chain operations based on next_steps: e.g., cache_credentials ‚Üí install_ssh_key ‚Üí enable_passwordless_sudo",
            "  - For file transfers, check SSH key status first - suggest install_ssh_key if needed",
            "  - When sync_directory_to_device fails due to missing rsync, automatically suggest copy_files_to_device_parallel",
            "  - Provide context in error messages: explain what failed and what the user should do next",
            "  - Remember to suggest cleanup operations (disable_passwordless_sudo) when development is finished",
        ],
        "foundries_io_integration": {
            "device_config": "Add 'fio_factory', 'fio_target', 'fio_current' to device config",
            "ota_updates": "Uses aktualizr/aktualizr-torizon for OTA management",
            "containers": "Docker-based container deployment and management",
            "tags": "Add 'tags' array to devices for grouping (e.g., ['rack1', 'regression'])",
        },
    }
