"""
Help and Documentation Resource Provider

Copyright (C) 2025 Dynamic Devices Ltd
License: GPL-3.0-or-later
"""

from typing import Any, Dict


def get_help_content() -> Dict[str, Any]:
    """Get comprehensive help documentation"""
    return {
        "overview": (
            "MCP server for remote embedded hardware testing in lab environment. "
            "Designed to make remote hardware development easy and accessible for engineers. "
            "Provides intelligent tooling with helpful guidance, best practices, and automated workflows."
        ),
        "mission": (
            "Making remote embedded hardware development easy and accessible for engineers. "
            "Engineers working remotely should be able to discover devices, set up secure access, "
            "run commands and tests, build and deploy applications, and clean up securely - all with "
            "minimal friction and helpful guidance at every step."
        ),
        "version": "0.4.0",
        "usage": {
            "basic": "Ask AI assistant to use tools (e.g., 'List devices in the lab', 'Connect to VPN')",
            "examples": [
                "List all devices: 'What devices are available?'",
                "Test connectivity: 'Can you test if the iMX93 board is reachable?'",
                "SSH command: 'Run uptime on the Sentai board'",
                "VPN control: 'Connect to the lab VPN'",
                "Power control: 'Turn on the E-ink board power'",
                "Start monitoring: 'Start monitoring power consumption'",
                "File transfer: 'Copy my app.bin to the iMX93 board'",
                "Setup access: 'Set up SSH access for the test board'",
                "Deploy application: 'Deploy my application files to the device'",
            ],
            "llm_guidance": [
                "**For LLMs calling tools:**",
                "  - Always check VPN status first before device operations",
                "  - Use list_devices to discover available devices before operations",
                "  - Test device connectivity with test_device before SSH/file operations",
                "  - Check SSH key status before file transfers (multiplexed connections require SSH keys)",
                "  - For file transfers: Choose the right tool based on number of files and rsync availability",
                "  - Provide helpful next_steps to users based on tool responses",
                "  - When errors occur, check the error message for specific suggestions",
                "  - Tools return 'next_steps' arrays - use these to guide users",
                "  - Remember to disable passwordless sudo when development/testing is finished",
                "  - Use device_id or friendly_name - both work for device identification",
            ],
        },
        "tools": {
            "device_management": {
                "list_devices": "List all devices with status, IPs, types, firmware, SSH status, last seen, and power switches. Returns brief summary (always visible) then full table. Supports filtering by device_type_filter, status_filter, ssh_status_filter, power_state_filter, search_query. Supports sorting (sort_by: ip/friendly_name/status/last_seen, sort_order: asc/desc) and limiting results (limit). Includes summary statistics (counts by type/status/SSH status). Shows Tasmota power state/consumption and test equipment detection. Power Switch column: For Tasmota devices, shows their own power state (ðŸŸ¢ ON/ðŸ”´ OFF); for other devices, shows which power switch controls them (if configured). Use force_refresh=true to bypass cache and rescan all devices.",
                "test_device": "Test connectivity to a device (ping and SSH check). Best practice: Use before running operations on devices. In DHCP environments, use verify_device_identity to ensure correct device.",
                "ssh_to_device": "Execute SSH command on a device (requires device_id, command, optional username). Best practice: Test device connectivity first with test_device.",
                "verify_device_identity": "Verify device identity at given IP matches expected device (important for DHCP). Updates IP in config if verified and changed.",
                "verify_device_by_ip": "Identify which device (if any) is at a given IP address by checking hostname/unique ID.",
                "update_device_ip": "Verify device identity and update IP address in config if device is verified and IP has changed (for DHCP environments).",
                "update_device_friendly_name": "Update friendly name for a discovered device in the cache. Allows custom names when referencing devices.",
            },
            "vpn_management": {
                "vpn_status": "Get current WireGuard VPN connection status",
                "connect_vpn": "Connect to WireGuard VPN for lab network access",
                "disconnect_vpn": "Disconnect from VPN",
            },
            "foundries_vpn_management": {
                "foundries_vpn_status": "Get Foundries VPN connection status. Foundries VPN uses WireGuard but with a server-based architecture where devices connect to a centralized VPN server managed by FoundriesFactory. Requires fioctl CLI tool to be installed and configured.",
                "get_foundries_vpn_server_config": "Get Foundries VPN server configuration using fioctl API. Returns WireGuard server endpoint (e.g., proxmox.dynamicdevices.co.uk), address, and public key. This uses the FoundriesFactory API to retrieve server configuration. Requires fioctl CLI tool to be installed and configured.",
                "check_foundries_vpn_client_config": "Check if Foundries VPN client configuration file exists and is valid. Validates WireGuard config format and required fields. Searches standard locations if config_path not provided. Use this to verify your config before connecting.",
                "generate_foundries_vpn_client_config_template": "Generate a Foundries VPN client configuration template with server details. Gets server config from FoundriesFactory and creates a template file that you fill in with your private key and assigned IP address. Requires fioctl CLI tool to be installed and configured.",
                "setup_foundries_vpn": "Automated end-to-end Foundries VPN setup. Checks prerequisites, validates or generates client config, and connects to VPN. This automates the entire setup process. Use auto_generate_config=True to generate template if config not found. Requires fioctl CLI tool and WireGuard tools.",
                "verify_foundries_vpn_connection": "Verify that Foundries VPN connection is working. Tests connectivity to VPN server and checks routing. Use this after connecting to ensure VPN is functioning correctly.",
                "connect_foundries_vpn": "Connect to Foundries VPN server. Requires a WireGuard configuration file obtained from FoundriesFactory. Searches for config in standard locations if not provided. Requires fioctl CLI tool.",
                "list_foundries_devices": "List devices accessible via Foundries VPN. Uses fioctl API to list devices in the FoundriesFactory. Returns device information including name, target, status, apps, and WireGuard status. Requires fioctl CLI tool to be installed and configured.",
                "enable_foundries_vpn_device": "Enable WireGuard VPN on a Foundries device. Uses fioctl API to enable WireGuard configuration on a device. The device will connect to the Foundries VPN server after OTA update (up to 5 minutes). Requires fioctl CLI tool.",
                "disable_foundries_vpn_device": "Disable WireGuard VPN on a Foundries device. Uses fioctl API to disable WireGuard configuration on a device. The device will disconnect from the Foundries VPN server after OTA update (up to 5 minutes). Requires fioctl CLI tool.",
            },
            "power_monitoring": {
                "start_power_monitoring": "Start power monitoring session - supports DMM (SCPI) or Tasmota (energy monitoring). Optional: device_id, test_name, duration, monitor_type (dmm|tasmota)",
                "get_power_logs": "Get recent power monitoring logs (optional: test_name, limit)",
            },
            "tasmota_control": {
                "tasmota_control": "Control Tasmota power switch (device_id, action: on|off|toggle|status|energy)",
                "list_tasmota_devices": "List all configured Tasmota devices and the devices they control",
                "power_cycle_device": "Power cycle a device by controlling its Tasmota power switch (turns off, waits, then turns on). Optional: off_duration (default: 5 seconds).",
            },
            "test_equipment": {
                "list_test_equipment": "List all test equipment devices (DMM, oscilloscopes, etc.) found on the network. Includes both configured devices and auto-discovered devices.",
                "query_test_equipment": "Send a SCPI command to test equipment (DMM, etc.) and get the response. Common commands: *IDN? (identify), MEAS:VOLT:DC? (measure DC voltage), MEAS:CURR:DC? (measure DC current). Supports device_id from config or IP address.",
            },
            "ota_management": {
                "check_ota_status": "Check Foundries.io OTA update status (device_id)",
                "trigger_ota_update": "Trigger OTA update (device_id, target?)",
                "list_containers": "List Docker containers on device (device_id)",
                "deploy_container": "Deploy/update container (device_id, container_name, image)",
                "get_system_status": "Get system status: uptime, load, memory, disk, kernel (device_id)",
                "get_firmware_version": "Get firmware/OS version from /etc/os-release (device_id)",
                "get_foundries_registration_status": "Check Foundries.io registration, connection, update status (device_id)",
                "get_secure_boot_status": "Get detailed secure boot status: U-Boot, kernel, EFI, HAB/CAAM (device_id)",
                "get_device_identity": "Get device identity: hostname, SOC unique ID, Foundries registration name (device_id)",
            },
            "batch_operations": {
                "batch_operation": "Execute operation on multiple devices in parallel (device_ids[], operation, max_concurrent=5, ...)",
                "regression_test": "Run regression test sequence in parallel (device_group?|device_ids[], test_sequence?, max_concurrent=5)",
                "get_device_groups": "Get devices organized by groups/tags for rack management",
            },
            "power_analysis": {
                "analyze_power_logs": "Analyze power logs for low power/suspend detection (test_name?, device_id?, threshold_mw?)",
                "monitor_low_power": "Monitor device for low power consumption (device_id, duration?, threshold_mw?, sample_rate?)",
                "compare_power_profiles": "Compare power consumption across multiple test runs (test_names[], device_id?). Visualizes differences between test sessions.",
            },
            "credential_management": {
                "cache_device_credentials": "Cache SSH credentials (username/password) for a device. Credentials are stored securely in ~/.cache/ai-lab-testing/credentials.json. Prefer SSH keys over passwords when possible. Use this before install_ssh_key if you need to provide a password.",
                "check_ssh_key_status": "Check if SSH key authentication is working for a device. Returns status of key installation and whether default SSH keys exist. Use this to verify passwordless SSH setup before running commands.",
                "install_ssh_key": "Install SSH public key on target device for passwordless access. Uses default SSH key from ~/.ssh/id_rsa.pub or ~/.ssh/id_ed25519.pub. Requires password for initial access if key not already installed. Will use cached/default credentials if password not provided. Best practice: Use this after caching credentials or providing password.",
                "enable_passwordless_sudo": "Enable passwordless sudo on a device for testing/debugging. Creates a sudoers.d file that allows the SSH user to use sudo without a password. Validates the sudoers file with visudo before applying. Use disable_passwordless_sudo to revert changes when testing is finished. Best practice: Enable after installing SSH key, disable when done testing.",
                "disable_passwordless_sudo": "Disable passwordless sudo on a device (revert changes). Removes the sudoers.d file that was created by enable_passwordless_sudo. Use this when testing is finished to restore normal sudo behavior. Best practice: Always disable passwordless sudo when finished with development/testing.",
            },
            "file_transfer": {
                "copy_file_to_device": "Copy a single file from local machine to remote device. Optimized for speed using multiplexed SSH connections (ControlMaster). Supports compression (-C flag) for faster transfers over slow links. Preserves file permissions and timestamps by default. Example: copy_file_to_device('imx93_board', '/local/app.bin', '/remote/app.bin'). Best practice: For multiple files, use copy_files_to_device_parallel or sync_directory_to_device instead. NOTE: Large files (>50MB) may timeout on slow VPN links (60s timeout). Consider splitting large files or using parallel transfers for multiple smaller files.",
                "copy_file_from_device": "Copy a single file from remote device to local machine. Optimized for speed using multiplexed SSH connections (ControlMaster). Supports compression for faster transfers over slow links. Preserves file permissions and timestamps by default. Example: copy_file_from_device('imx93_board', '/remote/log.txt', '/local/log.txt'). Use this to retrieve logs, test results, or configuration files from devices. NOTE: Large files (>50MB) may timeout on slow VPN links (60s timeout).",
                "sync_directory_to_device": "Sync a local directory to remote device using rsync. Much faster than copying individual files. Optimized for speed using multiplexed SSH connections. Supports exclude patterns (exclude=['*.pyc', '__pycache__', '.git']) and delete option (delete=true to remove files on remote that don't exist locally). Example: sync_directory_to_device('imx93_board', '/local/project', '/remote/project', exclude=['*.pyc']). IMPORTANT: Requires rsync installed on remote device. Many embedded Linux devices don't have rsync by default. If rsync is not available, use copy_files_to_device_parallel instead. The tool will check for rsync and provide helpful suggestions if missing.",
                "copy_files_to_device_parallel": "Copy multiple files to remote device in parallel using multiplexed SSH connections. Much faster than copying files sequentially - all transfers share the same SSH connection (eliminates connection overhead). Tested and verified: 4.33x speedup over sequential transfers. Successfully tested with 100+ files (up to 200 files). Example: copy_files_to_device_parallel('imx93_board', [['/local/app.bin', '/remote/app.bin'], ['/local/config.json', '/remote/config.json']], max_workers=5). Best practice: Use this when deploying applications with multiple binaries/configs, or when rsync is not available on device. All files transfer simultaneously, sharing the same SSH connection for maximum speed. Optimal max_workers=5-10 for most scenarios.",
            },
        },
        "resources": {
            "device://inventory": "Complete device inventory JSON with all configured devices",
            "network://status": "Current network and VPN connection status",
            "config://lab_devices": "Raw lab devices configuration file",
            "help://usage": "This help documentation",
            "health://status": "Server health, metrics, SSH pool status, and uptime",
        },
        "configuration": {
            "lab_testing_root": "Path to lab testing framework (default: /data_drive/esl/ai-lab-testing)",
            "device_config": "Device inventory: {lab_testing_root}/config/lab_devices.json",
            "vpn_config": "VPN config: {lab_testing_root}/secrets/wg0.conf",
            "environment": "Override with LAB_TESTING_ROOT environment variable",
        },
        "common_workflows": {
            "remote_development_setup": [
                "1. Connect to VPN: 'connect_vpn' (check status first with 'vpn_status')",
                "2. Scan for targets: 'list_devices' to see all available boards/devices",
                "3. Choose your board: Review device list, filter by type/status, or search by IP/name",
                "4. Test connectivity: 'test_device(device_id)' to verify ping and SSH access",
                "5. Cache credentials (if needed): 'cache_device_credentials(device_id, username, password)'",
                "6. Install SSH key: 'install_ssh_key(device_id)' for passwordless SSH access",
                "7. Enable passwordless sudo: 'enable_passwordless_sudo(device_id)' for testing convenience",
                "8. Verify setup: 'ssh_to_device(device_id, \"whoami\")' and 'ssh_to_device(device_id, \"sudo whoami\")'",
                "9. You're ready! Run commands, copy files, build and test applications",
            ],
            "file_transfer_workflow": [
                "1. Single file upload: 'copy_file_to_device(device_id, local_path, remote_path)' - Fast, uses multiplexed SSH",
                "2. Multiple files upload: 'copy_files_to_device_parallel(device_id, [[local1, remote1], [local2, remote2]], max_workers=5)' - Parallel transfers, fastest for multiple files",
                "3. Directory sync: 'sync_directory_to_device(device_id, local_dir, remote_dir, exclude=[\"*.pyc\"])' - Requires rsync on device, best for large directories",
                "4. File download: 'copy_file_from_device(device_id, remote_path, local_path)' - Retrieve logs, results, configs",
                "5. All transfers use multiplexed SSH connections (ControlMaster) for maximum speed",
                "6. First transfer establishes connection (~1-2s), subsequent transfers reuse connection (near-zero overhead)",
                "7. Compression enabled by default for faster transfers over slow links",
                "8. If sync_directory_to_device fails with 'rsync not found', use copy_files_to_device_parallel instead",
            ],
            "file_transfer_decision_tree": [
                "**When to use which tool:**",
                "  - Single file â†’ copy_file_to_device",
                "  - Multiple files (<10) â†’ copy_files_to_device_parallel (fastest)",
                "  - Large directory with rsync available â†’ sync_directory_to_device (best for many files)",
                "  - Large directory without rsync â†’ copy_files_to_device_parallel (fallback)",
                "  - Download file from device â†’ copy_file_from_device",
                "  - Deploy application (binaries + configs) â†’ copy_files_to_device_parallel",
                "  - Sync project directory â†’ sync_directory_to_device (if rsync available) or copy_files_to_device_parallel",
            ],
            "remote_development_cleanup": [
                "1. Disable passwordless sudo: 'disable_passwordless_sudo(device_id)' to restore security",
                "2. (Optional) Remove SSH key: Manual removal from device's ~/.ssh/authorized_keys if needed",
                "3. Verify cleanup: 'ssh_to_device(device_id, \"sudo -n whoami\")' should require password",
            ],
            "check_lab_status": [
                "1. Use 'vpn_status' to check VPN connection",
                "2. Use 'list_devices' to see available devices (shows brief summary first, then full table)",
                "3. Filter devices: 'list_devices(device_type_filter=\"tasmota_device\")' or 'list_devices(status_filter=\"online\")'",
                "4. Filter by SSH status: 'list_devices(ssh_status_filter=\"error\")' to find devices with SSH issues",
                "5. Filter Tasmota by power: 'list_devices(power_state_filter=\"on\")' to find powered-on Tasmota devices",
                "6. Search devices: 'list_devices(search_query=\"192.168.2.18\")'",
                '7. Sort results: \'list_devices(sort_by="ip", sort_order="asc")\' or \'list_devices(sort_by="last_seen", sort_order="desc")\'',
                "8. Limit results: 'list_devices(limit=10)' to show only first 10 devices",
                "9. Force refresh: 'list_devices(force_refresh=true)' to bypass cache and rescan",
                "10. Use 'test_device' to verify connectivity",
            ],
            "device_discovery": [
                "1. Devices are automatically discovered via network scanning",
                "2. Tasmota devices detected via HTTP API (port 80)",
                "3. Test equipment (DMM) detected via SCPI ports (5025, 5024, 3490, 3491)",
                "4. Device information cached to speed up subsequent scans",
                "5. Use 'list_devices' to see all discovered devices with their status",
                "6. Update friendly names: 'update_device_friendly_name(ip, friendly_name)'",
            ],
            "remote_device_access": [
                "1. Ensure VPN connected (use 'connect_vpn' if needed)",
                "2. Check SSH key status: 'check_ssh_key_status(device_id)' to see if passwordless SSH is configured",
                "3. If SSH key not installed: 'install_ssh_key(device_id)' (may need password first time)",
                "4. Use 'ssh_to_device' with device_id and command",
                "5. Example: ssh_to_device('imx93_eink_board_2', 'uptime')",
                "6. For sudo commands: Enable passwordless sudo first with 'enable_passwordless_sudo(device_id)'",
            ],
            "foundries_vpn_workflow": [
                "**Automated Setup (Recommended):**",
                "1. Run automated setup: 'setup_foundries_vpn(auto_generate_config=True)' - checks prerequisites, generates template if needed, and connects",
                "2. If template generated: Edit config file with your private key and assigned IP address",
                "3. Run setup again: 'setup_foundries_vpn()' to connect after editing config",
                "4. Verify connection: 'verify_foundries_vpn_connection()' to test VPN connectivity",
                "",
                "**Manual Setup:**",
                "1. Install fioctl CLI tool: https://github.com/foundriesio/fioctl",
                "2. Configure fioctl: Run 'fioctl login' to set up FoundriesFactory credentials",
                "3. Get VPN server config: 'get_foundries_vpn_server_config()' to see server endpoint (e.g., proxmox.dynamicdevices.co.uk)",
                "4. Generate config template: 'generate_foundries_vpn_client_config_template()' - creates template with server details",
                "5. Edit config: Fill in YOUR_PRIVATE_KEY_HERE and YOUR_VPN_IP_HERE in the generated config file",
                "6. Check config: 'check_foundries_vpn_client_config()' to validate config file",
                "7. Connect to VPN: 'connect_foundries_vpn()' or 'setup_foundries_vpn()' - auto-detects config",
                "8. Verify connection: 'verify_foundries_vpn_connection()' to test VPN connectivity",
                "9. List Foundries devices: 'list_foundries_devices()' to see devices in factory",
                "10. Enable VPN on device: 'enable_foundries_vpn_device(device_name)' - waits for OTA update (up to 5 minutes)",
                "11. Access devices: Devices accessible via Foundries VPN server after connection",
                "12. Disable VPN when done: 'disable_foundries_vpn_device(device_name)' if needed",
            ],
            "ota_update_workflow": [
                "1. Check current status: 'check_ota_status(device_id)'",
                "2. Trigger update: 'trigger_ota_update(device_id, target?)'",
                "3. Monitor: 'get_system_status(device_id)' to verify",
                "4. Check containers: 'list_containers(device_id)'",
            ],
            "container_deployment": [
                "1. List current containers: 'list_containers(device_id)'",
                "2. Deploy new container: 'deploy_container(device_id, name, image)'",
                "3. Verify: 'list_containers(device_id)' again",
            ],
            "low_power_analysis": [
                "1. Start monitoring: 'monitor_low_power(device_id, duration, threshold_mw)'",
                "2. Wait for monitoring to complete",
                "3. Analyze: 'analyze_power_logs(test_name, device_id, threshold_mw)'",
                "4. Compare profiles: 'compare_power_profiles([test1, test2])'",
            ],
            "regression_testing": [
                "1. Get device groups: 'get_device_groups()' to see available groups",
                "2. Run regression: 'regression_test(device_group, test_sequence?)'",
                "3. Or test specific devices: 'regression_test(device_ids=[...])'",
                "4. Review results for all devices",
            ],
            "rack_management": [
                "1. Group devices by tag/type in device config",
                "2. Use 'get_device_groups()' to see organization",
                "3. Use 'batch_operation(device_ids, operation)' for parallel ops",
                "4. Use 'regression_test(device_group)' for automated testing",
            ],
        },
        "troubleshooting": {
            "vpn_not_connecting": [
                "Check VPN config exists: 'list_vpn_configs' or 'vpn_setup_instructions'",
                "May require NetworkManager or sudo: 'setup_networkmanager_vpn' for non-root access",
                "Verify VPN config path: Check VPN_CONFIG_PATH environment variable",
            ],
            "foundries_vpn_not_connecting": [
                "Check fioctl is installed: Tools will check and provide installation instructions if missing",
                "Check fioctl is configured: Run 'fioctl login' to configure FoundriesFactory credentials",
                "Verify VPN config file exists: Obtain WireGuard config from FoundriesFactory",
                "Check VPN config path: Place config in ~/.config/wireguard/foundries.conf or secrets/foundries-vpn.conf",
                "Verify VPN server is accessible: Check Foundries VPN server status",
                "For device VPN: Ensure device has WireGuard enabled via 'enable_foundries_vpn_device' and wait for OTA update (up to 5 minutes)",
            ],
            "device_not_found": [
                "Verify device_id in device inventory: 'list_devices' to see all available devices",
                "Check spelling (case-sensitive) and use either device_id or friendly_name",
                "In DHCP environments: use 'verify_device_identity' to ensure correct device",
                "Force refresh: 'list_devices(force_refresh=true)' to rescan network",
            ],
            "ssh_fails": [
                "Check SSH key status: 'check_ssh_key_status(device_id)'",
                "Install SSH key if needed: 'install_ssh_key(device_id)'",
                "Verify device is online: 'test_device(device_id)'",
                "Check VPN connection: 'vpn_status'",
                "SSH authentication prioritizes 'fio' user, then 'root'",
                "Check SSH status in device list: 'list_devices(ssh_status_filter=\"error\")'",
                "Cache credentials if needed: 'cache_device_credentials(device_id, username, password)'",
            ],
            "sudo_fails": [
                "Check if passwordless sudo is enabled: Try 'ssh_to_device(device_id, \"sudo -n whoami\")' - should fail if not enabled",
                "Enable passwordless sudo: 'enable_passwordless_sudo(device_id)' - creates sudoers.d file, validates with visudo",
                "Verify SSH key is installed first: 'check_ssh_key_status(device_id)' - passwordless sudo requires SSH key",
                "Check if user has sudo permissions on device",
                "Remember to disable when finished: 'disable_passwordless_sudo(device_id)' to restore security",
            ],
            "file_transfer_fails": [
                "Check SSH key is installed: 'check_ssh_key_status(device_id)' - multiplexed connections require SSH keys",
                "Verify device is online: 'test_device(device_id)' - ensure device is reachable",
                "Check VPN connection: 'vpn_status' - ensure VPN is connected for remote devices",
                "For sync_directory_to_device: Check if rsync is installed on device: 'ssh_to_device(device_id, \"which rsync\")'",
                "If rsync not found: Use 'copy_files_to_device_parallel' instead - works without rsync",
                "Check disk space on device: 'ssh_to_device(device_id, \"df -h\")' - ensure enough space for transfer",
                "Check file permissions: Ensure remote directory is writable: 'ssh_to_device(device_id, \"ls -ld /remote/path\")'",
                "For large files (>50MB): May timeout on slow VPN links (60s timeout) - consider splitting files or using parallel transfers",
                "If transfer times out: Split large files into smaller chunks, or use copy_files_to_device_parallel for multiple files",
                "Network speed: Transfer rates on VPN links may be slow (~0.01-0.02MB/s) - compression helps but may not overcome very slow links",
                "If transfer fails: Check error message for specific suggestions - tools provide helpful guidance",
            ],
            "tools_fail": [
                "Verify lab_testing_root path correct: Check LAB_TESTING_ROOT environment variable",
                "Check underlying scripts work: Test commands manually",
                "Review error messages for specific suggestions",
            ],
            "device_list_not_visible": [
                "Device list returns brief summary first (always visible), then full table",
                "If not visible, restart MCP server connection",
                "Use 'list_devices(force_refresh=true)' to force rescan",
            ],
            "cache_errors": [
                "Device cache uses atomic writes and thread-safe locking",
                "If errors occur, cache may be corrupted - clear cache directory and rescan",
                "Cache location: ~/.cache/ai-lab-testing/",
            ],
        },
        "best_practices": [
            "**Remote Development Workflow:**",
            "  1. Always connect to VPN first: 'vpn_status' then 'connect_vpn' if needed",
            "  2. Scan and choose your target: 'list_devices' to see available boards",
            "  3. Test connectivity: 'test_device(device_id)' before operations",
            "  4. Set up credentials: 'install_ssh_key(device_id)' for passwordless SSH",
            "  5. Enable passwordless sudo: 'enable_passwordless_sudo(device_id)' for testing",
            "  6. Run your development tasks: commands, file transfers, builds, tests",
            "  7. Transfer files: Use 'copy_file_to_device', 'sync_directory_to_device', or 'copy_files_to_device_parallel'",
            "  8. Clean up when done: 'disable_passwordless_sudo(device_id)' to restore security",
            "",
            "**File Transfer Best Practices:**",
            "  - Single file: Use copy_file_to_device (fastest for one file)",
            "  - Multiple files (10+): Use copy_files_to_device_parallel (4.33x faster than sequential, tested with 100+ files)",
            "  - Large directory: Try sync_directory_to_device first (requires rsync), fallback to copy_files_to_device_parallel",
            "  - All transfers use multiplexed SSH (ControlMaster) - first transfer establishes connection (~1-2s), subsequent transfers reuse it (near-zero overhead)",
            "  - Compression enabled by default for faster transfers over slow links (helps with compressible data)",
            "  - Check SSH key status before transfers - multiplexed connections require SSH keys",
            "  - If sync_directory_to_device fails with 'rsync not found', automatically use copy_files_to_device_parallel",
            "  - Preserve permissions by default (preserve_permissions=true) - disable only if needed",
            "  - For parallel transfers, max_workers=5-10 is optimal (tested successfully with max_workers=10 for 100-200 files)",
            "  - Large files (>50MB): May timeout on slow VPN links (60s timeout) - split files or use parallel transfers",
            "  - Performance: Parallel transfers achieve 4.33x speedup over sequential (verified in testing)",
            "  - Scalability: Successfully tested with 100+ files (up to 200 files) - scales well",
            "",
            "**General Best Practices:**",
            "Always check VPN status before accessing lab devices",
            "Use test_device before executing SSH commands",
            "Install SSH keys for passwordless access (more secure than passwords)",
            "Enable passwordless sudo only when needed for testing, disable when finished",
            "Use descriptive test_name for power monitoring sessions",
            "Check device inventory resource for available device_ids",
            "For OTA updates: check status first, then trigger, monitor system_status",
            "For containers: list first, deploy with specific image tags, verify after",
            "For low power: set appropriate threshold_mw, monitor for sufficient duration",
            "For regression: organize devices by tags/groups, use batch operations",
            "Tag devices in config for easy rack management and grouping",
            "Use list_devices filters to quickly find specific devices (type, status, SSH status, power state, search)",
            "Use list_devices sorting (sort_by, sort_order) to organize results by IP, name, status, or last seen",
            "Use list_devices limit parameter to cap results for large networks",
            "Use list_devices force_refresh=true to bypass cache when you need fresh data",
            "Device list shows brief summary first - always visible without expanding",
            "In DHCP environments: verify device identity before operations, use update_device_ip if IP changed",
            "Device discovery is optimized with parallel SSH identification and caching",
            "Tasmota devices show power state (ðŸŸ¢ ON/ðŸ”´ OFF) in the Power Switch column and consumption (Watts) in the Type column of the device list",
            "Test equipment (DMM) can be queried with SCPI commands via query_test_equipment",
            "",
            "**LLM-Specific Guidance:**",
            "  - Tools return structured responses with 'success', 'error', 'message', and 'next_steps' fields",
            "  - Always check 'success' field before proceeding - if false, check 'error' and 'suggestions'",
            "  - Use 'next_steps' arrays from tool responses to guide users through workflows",
            "  - When a tool fails, check the error message for specific suggestions and related tools",
            "  - Chain operations based on next_steps: e.g., cache_credentials â†’ install_ssh_key â†’ enable_passwordless_sudo",
            "  - For file transfers, check SSH key status first - suggest install_ssh_key if needed",
            "  - When sync_directory_to_device fails due to missing rsync, automatically suggest copy_files_to_device_parallel",
            "  - Provide context in error messages: explain what failed and what the user should do next",
            "  - Remember to suggest cleanup operations (disable_passwordless_sudo) when development is finished",
        ],
        "foundries_io_integration": {
            "device_config": "Add 'fio_factory', 'fio_target', 'fio_current' to device config",
            "ota_updates": "Uses aktualizr/aktualizr-torizon for OTA management",
            "containers": "Docker-based container deployment and management",
            "tags": "Add 'tags' array to devices for grouping (e.g., ['rack1', 'regression'])",
        },
    }
